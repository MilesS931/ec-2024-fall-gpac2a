
# tree_genotype.py

import random
from copy import deepcopy
from parse_tree import *

class TreeGenotype():
    def __init__(self, genes=None):
        self.fitness = None
        self.genes = genes or ParseTree()


    @classmethod
    def initialization(cls, mu, depth_limit, terminals, nonterminals):
        if not terminals or not nonterminals: 
            raise ValueError("Terminals and nonterminals must be provided and non-empty.")

        # 2a TODO: Initialize genes member variables of individuals
        #          in population using ramped half-and-half.
        #          Pass **kwargs to your functions to give them
        #          the sets of terminal and nonterminal primitives.
        # Copilot helped with code
        # I do not know python yet
        population = []
        for depth in range(1, depth_limit + 1):
            for _ in range(mu // (2 * depth_limit)):
                # Use the full method
                full_tree = ParseTree.full(0, terminals, nonterminals, depth) 
                population.append(cls(genes=full_tree))
                # Use the grow method
                grow_tree = ParseTree.grow(0, terminals, nonterminals, depth)
                population.append(cls(genes=grow_tree))
        
        # If the population size is not reached, fill with random trees
        while len(population) < mu:
            depth = random.randint(1, depth_limit)
            if len(population) % 2 == 0:
                tree = ParseTree.full(0, terminals, nonterminals, depth)
            else:
                tree = ParseTree.grow(0, terminals, nonterminals, depth)
            population.append(cls(genes=tree))

        return population


    def serialize(self):
        # 2a TODO: Return a string representing self.genes in the required format.
        # Copilot helped with code
        # I do not know python yet
        if self.genes is None: 
            return "" 
        stack = [(self.genes, 0)] 
        result = [] 
        while stack: 
            node, depth = stack.pop() 
            if node is not None: 
                value_str = str(node.value) if isinstance(node.value, (int, float)) else node.value 
                result.append("|" * depth + value_str) 
                stack.append((node.right, depth + 1)) 
                stack.append((node.left, depth + 1)) 
        
        return "\n".join(result)


    def deserialize(self, serialization):
        # 2a TODO: Complete the below code to recreate self.genes from serialization,
        #          which is a string generated by your serialize method.
        #          We have provided logic for tree traversal to help you get started,
        #          but you need to flesh out this function and make the genes yourself.
        # TODO: Create the root node yourself here based on lines[0]
        # Copilot helped with code
        # I do not know python yet
        lines = serialization.split('\n') 
        root_value = lines[0].strip('|') 
        root = ParseTree(value=root_value) 
        parent_stack = [(root, 0)]
        
        for line in lines[1:]: 
            my_depth = line.count('|') 
            my_primitive = line.strip('|') 
            # TODO: Create a node using the above variables as appropriate.
            node = ParseTree(value=my_primitive) 
            
            while parent_stack and parent_stack[-1][1] >= my_depth: 
                parent_stack.pop() 
                
            parent, parent_depth = parent_stack[-1] 
            if parent.left is None: 
                parent.left = node 
            else: 
                parent.right = node
                
            parent_stack.append((node, my_depth)) 

        # TODO: Use the data structure you've created to assign self.genes.
        self.genes = root


    def recombine(self, mate, depth_limit, **kwargs):
        child = self.__class__()

        # 2b TODO: Recombine genes of mate and genes of self to
        #          populate child's genes member variable.
        #          We recommend using deepcopy, but also recommend
        #          that you deepcopy the minimal amount possible.
        # Ensure max_depth is properly set
        max_depth = depth_limit
        if max_depth is None: 
            raise ValueError("max_depth is not set correctly")
        
        terminals = kwargs.get('terminals') 
        nonterminals = kwargs.get('nonterminals')

        # Copy self and mate to avoid modifying the original parents 
        child = TreeGenotype(deepcopy(self.genes)) 
        mate_copy = deepcopy(mate.genes) 
        
        # Select random subtrees 
        child_subtree, child_parent, child_side = self._select_random_subtree(child.genes) 
        mate_subtree, mate_parent, mate_side = self._select_random_subtree(mate_copy) 
        
        # Swap subtrees 
        if child_parent is None: 
            child.genes = mate_subtree 
        else: 
            setattr(child_parent, child_side, mate_subtree) 
            
        # Ensure the child does not exceed max depth 
        if self._get_depth(child.genes) > max_depth: 
            child.genes = self._truncate_tree(child.genes, max_depth, terminals=terminals)
        return child
    
    def _select_random_subtree(self, tree):
        parent = None
        side = None
        while True:
            if not tree.left and not tree.right:
                return tree, parent, side
            else:
                if random.choice([True, False]):
                    if tree.left:
                        parent, side = tree, 'left'
                        tree = tree.left
                    else:
                        parent, side = tree, 'right'
                        tree = tree.right
                else:
                    if tree.right:
                        parent, side = tree, 'right'
                        tree = tree.right
                    else:
                        parent, side = tree, 'left'
                        tree = tree.left

    def _get_depth(self, tree):
        if not tree:
            return 0
        return 1 + max(self._get_depth(tree.left), self._get_depth(tree.right))
    
    def _truncate_tree(self, tree, max_depth, terminals):
        if max_depth <= 0:
            return ParseTree(value=random.choice(terminals))
        if tree.left:
            tree.left = self._truncate_tree(tree.left, max_depth - 1, terminals=terminals)
        if tree.right:
            tree.right = self._truncate_tree(tree.right, max_depth - 1, terminals=terminals)
        return tree


    def mutate(self, depth_limit, **kwargs):
        mutant = self.__class__()
        mutant.genes = deepcopy(self.genes)

        # 2b TODO: Mutate mutant.genes to produce a modified tree.

        return mutant